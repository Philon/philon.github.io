<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo48x48.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo48x48.png">
  <link rel="mask-icon" href="/images/logo.png" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ixx.life","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一个程序员的成长足迹">
<meta property="og:type" content="website">
<meta property="og:title" content="自增人生">
<meta property="og:url" content="https://ixx.life/page/13/index.html">
<meta property="og:site_name" content="自增人生">
<meta property="og:description" content="一个程序员的成长足迹">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Philon">
<meta property="article:tag" content="自律 arts 编程 开发 c&#x2F;c++ java web go 读书 写作">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ixx.life/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>自增人生</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">自增人生</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">何以解忧，唯有 i++</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa  fa-book fa-fw"></i>读书写作</a>

  </li>
        <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-pen fa-fw"></i>学习笔记</a>

  </li>
        <li class="menu-item menu-item-leetcode">

    <a href="/leetcode/" rel="section"><i class="fa fa-fire fa-fw"></i>LeetCode</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ixx.life/97ThingsEveryProgrammerShouldKnow/31/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Philon">
      <meta itemprop="description" content="一个程序员的成长足迹">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="自增人生">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/97ThingsEveryProgrammerShouldKnow/31/" class="post-title-link" itemprop="url">别碰代码！</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-05 07:50:47" itemprop="dateCreated datePublished" datetime="2019-03-05T07:50:47+08:00">2019-03-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/" itemprop="url" rel="index"><span itemprop="name">程序员应该知道的97件事</span></a>
                </span>
            </span>

          
            <span id="/97ThingsEveryProgrammerShouldKnow/31/" class="post-meta-item leancloud_visitors" data-flag-title="别碰代码！" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/97ThingsEveryProgrammerShouldKnow/31/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/97ThingsEveryProgrammerShouldKnow/31/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_31/">Don’t Touch that Code!</a></p>
<p>在我们每个人身上都发生过。你的代码放到预演服务器上用于系统测试，然后测试经理反馈她发现了个问题。你的第一反应就是“快，让我修复它——我知道错误在哪儿。”</p>
<p>从更大的意义上来说，尽管，作为一个开发者犯的错，你觉得你应该去访问预演服务器。</p>
<p>大多数基于web的开发环境中，架构可以像这样分解：</p>
<ul>
<li>本地开发，并在开发者机器上完成单元测试</li>
<li>手动或自动完成在开发服务器上集成测试</li>
<li>QA团队和用户访问预演服务器完成测试</li>
<li>(发布到)生产服务器</li>
</ul>
<p>是的，那里还有其它的服务器和服务，就像源码控制和票据，但你获得了注意。使用这个模型，一个程序员——甚至是一个有资历的程序员——应该永远不要访问除了开发服务器意外的东西。很多开发是在开发者本地机器用他们喜欢的IDE、虚拟机上完成的，为了好运，还会撒上适量的黑魔法。</p>
<p>一旦进入SCC检查，不论是自动还是手动，都应该将其从开发服务器转交出去，并可以在其它地方被测试和调整，以确保一切工作正常。尽管，从这点来看，开发者在此过程中只能是一个观众。</p>
<p>预演经理应该为QA团队打包并转移代码到预演服务器。就像开发者不需要访问任何开发服务器意外的事情一样，QA团队和用户也要碰任何在开发服务器上的东西。如果它准备接受测试，切出发布(分支)并移交，不要再让用户到开发服务器上“只是看一点东西，真的很快”。记住，除非整个工程代码都是你写的，否则其他人会在上面改代码，并且他们可能并没有准备好让用户看。发布经理才是唯一应该访问这两者的人。</p>
<p>在任何，所有情况下——都不应该——让一个开发人员去访问生产服务器。如果又问题，你的技术支持人员要么修复它，要么请求修复它。在SCC检入之后，它们将在此滚动一个补丁。我曾目睹过一些超大型的编程灾难发生，由于某些人(咳咳)违反了这条规则。如果它破掉了，生产可不是修复它的地方。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ixx.life/books/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Philon">
      <meta itemprop="description" content="一个程序员的成长足迹">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="自增人生">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/books/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/" class="post-title-link" itemprop="url">三人为虎-《乌合之众》读书感悟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-03 22:54:59" itemprop="dateCreated datePublished" datetime="2019-03-03T22:54:59+08:00">2019-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6/" itemprop="url" rel="index"><span itemprop="name">读书</span></a>
                </span>
            </span>

          
            <span id="/books/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/" class="post-meta-item leancloud_visitors" data-flag-title="三人为虎-《乌合之众》读书感悟" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/books/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/books/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我大概是在某个播客节目中听到本书的名字，同时因为对文革、网络喷子、游行示威、打砸等历史或现象多少有些兴趣，便怀着好奇心翻开了这本书。从《乌合之众：大众心理研究》的书名都能猜到，这本书就是讲群众行为和心理的，不论题材和角度都能，或多或少有些发人深省的地方。所以，想要对某些群体心理多些洞察力，这本书还是值得一读的。</p>
<p>但是，从文体内容而言，我感觉这本书就想一本心理学论文，不乏很多枯燥的长篇论述，食之无味。如果我是一名心理学家或者社会学家，那这本书也许能持续挑逗我的精神味蕾，可偏偏我就是个门外汉，那些长篇大论除了帮助我增加丝丝睡意外，好像也没什么能吸引我的地方。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/books/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ixx.life/GoInAction/chapter7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Philon">
      <meta itemprop="description" content="一个程序员的成长足迹">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="自增人生">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GoInAction/chapter7/" class="post-title-link" itemprop="url">七：并发模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-03 16:13:01" itemprop="dateCreated datePublished" datetime="2019-03-03T16:13:01+08:00">2019-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8AGO%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">《GO语言实战》学习笔记</span></a>
                </span>
            </span>

          
            <span id="/GoInAction/chapter7/" class="post-meta-item leancloud_visitors" data-flag-title="七：并发模式" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/GoInAction/chapter7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/GoInAction/chapter7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们可以通过goroutine和channel机制非常方便地编写并发业务，但就和面向对象与设计模式的关系一样，是一种思想具体落实到行动方针的过程，在牛逼的战略，没有基本的战术指导，也只是空谈。</p>
<p>因此，第七章并发模式，并没有太多语法上的新东西，而是利用goroutine和channel介绍了三种并发模式，分别适用于三种不同的业务场景。</p>
<ol>
<li>runner——给每个并发任务设置deadline，管理并发任务的生命周期</li>
<li>pool——利用有缓冲通道创建资源池，统一管理并发时的资源访问</li>
<li>work——利用无缓冲通道创建goroutine池，统一管理并发</li>
</ol>
<h2 id="runner"><a href="#runner" class="headerlink" title="runner"></a>runner</h2><p>先假设一个场景需求，比如http服务的并发，我们要为每个来自客户端的请求创建一个临时的并发响应任务，但这个最好在某个规定的时间内完成响应，否则就强制它退出，这样可以很好地避免某些情况下，一些并发任务卡死的情况，同时可以很好地管理每个并发的生命周期。  </p>
<p>runner就是为这样的场景应用而生的，runner可以理解为是一个运行管理器，所有的并发任务都要叫给它负责管理，它负责并发任务的启动、超时监控、强制中断等。</p>
<p>(由于我个人在阅读原著的时候是先讲runner的内部实现，再看实际应用，总感觉云里雾里的，觉得还是先通篇看一下如何运用runner，再来看其内部的实现，可能效果会好一点)</p>
<p>先来看runner的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testRunner</span><span class="params">()</span></span> &#123;</span><br><span class="line">  log.Println(<span class="string">&quot;Runner test starting work...&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个runner，并强制每个并发任务的超时时间为5秒</span></span><br><span class="line">  r := runner.New(<span class="number">3</span> * time.Second)</span><br><span class="line">  <span class="comment">// 循环创建10个并发任务，并将其丢给runner管理</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    r.Add(<span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="comment">// 这里只是模拟，每个并发任务都是睡眠它自身id的秒数</span></span><br><span class="line">      log.Printf(<span class="string">&quot;Processor - Task #%d.\n&quot;</span>, id)</span><br><span class="line">      time.Sleep(time.Duration(id) * time.Second)</span><br><span class="line">      log.Printf(<span class="string">&quot;Task #%d done.\n&quot;</span>, id)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次性启动runner内部的全部并发任务</span></span><br><span class="line">  <span class="keyword">if</span> err := r.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> err &#123;</span><br><span class="line">    <span class="keyword">case</span> runner.ErrTimeout:</span><br><span class="line">      <span class="comment">// 当并发任务中有任务执行超时，就立即返回</span></span><br><span class="line">      log.Println(<span class="string">&quot;Terminating due to timeout.&quot;</span>)</span><br><span class="line">      os.Exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">case</span> runner.ErrInterrupt:</span><br><span class="line">      <span class="comment">// 当程序被ctrl+c时，强制结束所有并发任务</span></span><br><span class="line">      log.Println(<span class="string">&quot;Terminating due to interrupt.&quot;</span>)</span><br><span class="line">      os.Exit(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  log.Println(<span class="string">&quot;Process end.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------程序输出---------------</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Runner test starting work...</span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">2.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">4.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">3.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">0.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Task #<span class="number">0</span> done.</span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">1.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">42</span> Task #<span class="number">1</span> done.</span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">43</span> Task #<span class="number">2</span> done.</span><br><span class="line"><span class="comment">// ----第3个及以后的任务因为要睡3秒以上，肯定会超时----</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">44</span> Terminating due to timeout.</span><br><span class="line"><span class="comment">// ----如何运行过程中按ctrl+c，会安全退出并提示----</span></span><br><span class="line">^C2019/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">49</span>:<span class="number">36</span> Terminating due to interrupt.</span><br></pre></td></tr></table></figure>

<p>可以看到，runner就是一个类型，需要用其创建对象后才能具体使用。而在外部，我们只需要定义好每个任务的函数，并简单的将它们添加到runner当中即可，剩下的全部交由runner自行管理。</p>
<p>现在再来看看runner类型是如何实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runner 在指定的超时时间内完成一组任务</span></span><br><span class="line"><span class="comment">// 并且在这个时间周期内接收系统的中断信号来结束这组任务</span></span><br><span class="line"><span class="keyword">type</span> Runner <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 从系统接收中断信号的通道</span></span><br><span class="line">  interrupt <span class="keyword">chan</span> os.Signal</span><br><span class="line">  <span class="comment">// 任务已完成的报告通道</span></span><br><span class="line">  complete <span class="keyword">chan</span> error</span><br><span class="line">  <span class="comment">// 任务超时的报告通道</span></span><br><span class="line">  timeout &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">  <span class="comment">// 任务列表</span></span><br><span class="line">  tasks []<span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrTimeout 任务执行超时时返回</span></span><br><span class="line"><span class="keyword">var</span> ErrTimeout = errors.New(<span class="string">&quot;received timeout&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrInterrupt 收到系统中断信号时返回</span></span><br><span class="line"><span class="keyword">var</span> ErrInterrupt = errors.New(<span class="string">&quot;received interrupt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 创建Runner的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(d time.Duration)</span> *<span class="title">Runner</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Runner&#123;</span><br><span class="line">    interrupt: <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>),</span><br><span class="line">    complete:  <span class="built_in">make</span>(<span class="keyword">chan</span> error),</span><br><span class="line">    timeout:   time.After(d),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add Runner的方法，将多个任务添加到Runner的任务列表中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runner)</span> <span class="title">Add</span><span class="params">(tasks ...<span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">  r.tasks = <span class="built_in">append</span>(r.tasks, tasks...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start Runner的方法，启动所有任务，并监听通道事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runner)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 开始接收系统的中断通知</span></span><br><span class="line">  signal.Notify(r.interrupt, os.Interrupt)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过gorouting并行启动所有任务列表中的任务</span></span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="built_in">len</span>(r.tasks))</span><br><span class="line">  <span class="keyword">for</span> i, t := <span class="keyword">range</span> r.tasks &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>, task <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">      task(id)</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;(i, t)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等待所有任务执行完成，并给“已完成通道”一个报告</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    r.complete &lt;- <span class="literal">nil</span></span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取无缓冲通道数据时，如果没准备好，会被阻塞</span></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> err := &lt;-r.complete: <span class="comment">// 任务正常实行完返回任务自身的“错误标示”</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  <span class="keyword">case</span> &lt;-r.timeout: <span class="comment">// 任务执行超时，返回超时错误</span></span><br><span class="line">    <span class="keyword">return</span> ErrTimeout</span><br><span class="line">  <span class="keyword">case</span> &lt;-r.interrupt: <span class="comment">// 如果收到ctrl+C则停止接收后续的信号</span></span><br><span class="line">    signal.Stop(r.interrupt)</span><br><span class="line">    <span class="keyword">return</span> ErrInterrupt</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于只是原型演示，runner的内部实现不算复杂，只需要记住一个核心思想<strong>无缓冲通道在没有数据读写的时候，会被阻塞</strong>。说千道万，runner就是利用了这个特性才得以在select语句中完成了：</p>
<ul>
<li>并行接收系统的中断信号——interrupt通道。</li>
<li>并行接收定时器的超时信号——timeout通道。</li>
</ul>
<h2 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h2><p>这里的pool是指资源池的意思，如果熟悉Java/C#中的“数据连接池”的概念，那这里的池大体就是这个意思了。</p>
<p>换而言之，在并发场景下，难免会遇到并发任务争夺临界资源的情况，还是以数据库访问为例：如果有1000个并发任务要去访问数据库，每个并发都需要完成建立连接——认证——查询——断开连接等操作，那不论是应用服务器还是数据库服务器，无疑都是巨大的负担。因此，通过创建10个数据库连接，并把这些“连接”当作资源放入“池”中，给所有的并发任务共享，每个并发在需要的时候从池中取出连接，完成查询后再放回池中，不仅能大幅降低CPU的负载，也能减少内存的开销。(但我个人觉得最爽的地方是，你的代码可以更专注地去query，而不必考虑connection本身😂)</p>
<p>同样，先来看看pool的运用过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  maxGoroutines  = <span class="number">25</span> <span class="comment">// 要使用的goroutine的数量</span></span><br><span class="line">  pooledResource = <span class="number">5</span>  <span class="comment">// 池中的资源的数量</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dbConnection 模拟要共享的资源</span></span><br><span class="line"><span class="keyword">type</span> dbConnection <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 实现io.Closer.Close接口，释放资源</span></span><br><span class="line"><span class="comment">// 让其可以被Pool管理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dbConn *dbConnection)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  log.Println(<span class="string">&quot;Close: Connection&quot;</span>, dbConn.ID)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idCounter 用来给每个连接分配唯一id</span></span><br><span class="line"><span class="keyword">var</span> idCounter <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// createConnection 创建唯一id的连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createConnection</span><span class="params">()</span> <span class="params">(io.Closer, error)</span></span> &#123;</span><br><span class="line">  id := atomic.AddInt32(&amp;idCounter, <span class="number">1</span>)</span><br><span class="line">  log.Println(<span class="string">&quot;Create: New Connection&quot;</span>, id)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;dbConnection&#123;id&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testPool Pool测试用例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testPool</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(maxGoroutines)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建管理连接池，并创建N个“连接”资源，加入池中</span></span><br><span class="line">  p, err := pool.New(createConnection, pooledResource)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建M个并发任务，模拟查询数据库</span></span><br><span class="line">  <span class="keyword">for</span> query := <span class="number">0</span>; query &lt; maxGoroutines; query++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(q <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      performQueries(q, p)</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;(query)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">  log.Println(<span class="string">&quot;Shutdown Program&quot;</span>)</span><br><span class="line">  p.Close() <span class="comment">// 关闭池</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performQueries</span><span class="params">(query <span class="keyword">int</span>, p *pool.Pool)</span></span> &#123;</span><br><span class="line">  conn, err := p.Acquire()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成查询后，将资源释放会池里</span></span><br><span class="line">  <span class="keyword">defer</span> p.Release(conn)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用随机睡眠1000微妙内的时长，来模拟查询中的耗时</span></span><br><span class="line">  time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond)</span><br><span class="line">  log.Printf(<span class="string">&quot;QID[%d] CID[%d]\n&quot;</span>, query, conn.(*dbConnection).ID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(可能是我没学习到位，我个人觉得pool模式并不是特别容易掌握，思想是很好理解的，但牵扯太多接口实现、有/无缓冲通道的特性等内容，所以代码可能要再多消化几遍。)</p>
<p>再看看pool包的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pool 资源池</span></span><br><span class="line"><span class="comment">// 管理一组资源，可以安全地在多个goroutine共享</span></span><br><span class="line"><span class="comment">// 实现 io.Closer接口</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">  m        sync.Mutex</span><br><span class="line">  resource <span class="keyword">chan</span> io.Closer</span><br><span class="line">  factory  <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.Closer, error)</span></span></span><br><span class="line">  closed   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrPoolClosed 资源池已关闭的错误标示</span></span><br><span class="line"><span class="keyword">var</span> ErrPoolClosed = errors.New(<span class="string">&quot;Pool has been closed&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 创建Pool的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(fn <span class="keyword">func</span>()</span> <span class="params">(io.Closer, error)</span>, <span class="title">size</span> <span class="title">uint</span>) <span class="params">(*Pool, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> size &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;size value too small&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;Pool&#123;</span><br><span class="line">    factory:  fn,</span><br><span class="line">    resource: <span class="built_in">make</span>(<span class="keyword">chan</span> io.Closer, size),</span><br><span class="line">  &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Acquire 从资源池中获取一个资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Acquire</span><span class="params">()</span> <span class="params">(io.Closer, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> r, ok := &lt;-p.resource:</span><br><span class="line">    <span class="comment">// 检查是否有空闲资源</span></span><br><span class="line">    log.Println(<span class="string">&quot;Acquire:&quot;</span>, <span class="string">&quot;Shared Resource&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ErrPoolClosed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果没有可用资源，就创建一个</span></span><br><span class="line">    log.Println(<span class="string">&quot;Acquire:&quot;</span>, <span class="string">&quot;New Resource&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> p.factory()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release 释放一个资源，将其放回资源池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Release</span><span class="params">(r io.Closer)</span></span> &#123;</span><br><span class="line">  p.m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果该资源已经被关闭，销毁这个资源</span></span><br><span class="line">  <span class="keyword">if</span> p.closed &#123;</span><br><span class="line">    r.Close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> p.resource &lt;- r:</span><br><span class="line">    <span class="comment">// 试图将该资源加入队列</span></span><br><span class="line">    log.Println(<span class="string">&quot;Release:&quot;</span>, <span class="string">&quot;In Queue&quot;</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果队列已满，关闭这个资源</span></span><br><span class="line">    log.Println(<span class="string">&quot;Release:&quot;</span>, <span class="string">&quot;Closing&quot;</span>)</span><br><span class="line">    r.Close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭资源池中的所有资源，并停止工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p.m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> p.closed &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p.closed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(p.resource)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭所有资源</span></span><br><span class="line">  <span class="keyword">for</span> r := <span class="keyword">range</span> p.resource &#123;</span><br><span class="line">    r.Close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pool资源池实现的核心思想是<strong>有缓冲通道读写时不会引起阻塞，select语句在通道内没有数据的情况下会自动执行default选项</strong>。</p>
<h2 id="work"><a href="#work" class="headerlink" title="work"></a>work</h2><p>work模式就是创建一个goroutine池，管理池中所有的goroutine统一执行。但它有别于runner模式，runner其实是负责监控池中的每个并发任务的生命周期的，而work则是负责池中的每个并发任务的执行顺序，即任务队列。</p>
<p>这个模式的好处在于，可以很好地控制程序运行的负载，比如突发情况下，某台服务器的http请求一瞬间到达100万，如果为了响应所有请求也在一瞬起启动100万个响应任务，那估计服务器就冒烟了。所以最好的方式就是限制并发任务数量，比如每次最多启动1万个响应，剩下的排队慢慢来。</p>
<p>因此，work就是一个并发任务的队列池，还是先看看如何运用的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = []<span class="keyword">string</span>&#123;</span><br><span class="line">  <span class="string">&quot;steve&quot;</span>,</span><br><span class="line">  <span class="string">&quot;bob&quot;</span>,</span><br><span class="line">  <span class="string">&quot;mary&quot;</span>,</span><br><span class="line">  <span class="string">&quot;therese&quot;</span>,</span><br><span class="line">  <span class="string">&quot;jason&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> namePrinter <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 实现Worker接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *namePrinter)</span> <span class="title">Task</span><span class="params">()</span></span> &#123;</span><br><span class="line">  log.Println(m.name)</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 设置工作池的“工位”为2，即每次只能有两个人工作</span></span><br><span class="line">  p := work.New(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="number">100</span> * <span class="built_in">len</span>(names)) <span class="comment">// 每人肩负100项任务，共5人</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次性把5 * 100个任务全部丢到工作池中</span></span><br><span class="line">  <span class="comment">// 相当于创建了500个goroutine</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">      np := namePrinter&#123;name: name&#125;</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p.Run(&amp;np) <span class="comment">// 将对象的任务丢到工作池中统一管理执行</span></span><br><span class="line">        wg.Done()</span><br><span class="line">      &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待所有任务在工作池中被完成</span></span><br><span class="line">  wg.Wait()</span><br><span class="line">  p.Shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码，namePrinter实现了work包内规定的<code>Task</code>接口之后，work的工作池就能够统一管理namePrinter对象了。这个namePrinter可以理解为某个业务的模拟，比如上面说的http响应任务(这里仅是简单地做个打印)。</p>
<p>而后，不论创建多少个namePrinter相关的goroutine(并发)，都只需简单地将其丢到工作池中Run(p.Run并没有立刻启动任务，工作池会根据情况自行安排)。</p>
<p>最后在看看work包的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Worker 必须满足接口，才能使用工作池</span></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">interface</span> &#123;</span><br><span class="line">  Task()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pool 工作池，相当于goroutines池管理</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">  work <span class="keyword">chan</span> Worker</span><br><span class="line">  wg   sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 创建工作池的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxGoroutines <span class="keyword">int</span>)</span> *<span class="title">Pool</span></span> &#123;</span><br><span class="line">  p := Pool&#123;</span><br><span class="line">    work: <span class="built_in">make</span>(<span class="keyword">chan</span> Worker),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p.wg.Add(maxGoroutines)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxGoroutines; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// p.work是通道，所有创建goroutine之后</span></span><br><span class="line">      <span class="comment">// for循环会被阻塞，直到p.work被关闭为止</span></span><br><span class="line">      <span class="keyword">for</span> w := <span class="keyword">range</span> p.work &#123;</span><br><span class="line">        w.Task()</span><br><span class="line">      &#125;</span><br><span class="line">      p.wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run 提交工作到工作池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Run</span><span class="params">(w Worker)</span></span> &#123;</span><br><span class="line">  p.work &lt;- w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shutdown 等待所有goroutines结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">close</span>(p.work)</span><br><span class="line">  p.wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>work的实现其实是非常简单的，<strong>核心思想是for-range循环时，无缓冲通道会阻塞</strong>，工作池是一个无缓冲通道，而每个for-range都相当于一个队列，当池中有数据是，所有的for-range都会争夺这个输入数据来处理，但如果某个队列本身已经在工作时，就没空再争夺通道内的数据。可以说是最简单有效的负载均衡。</p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><ul>
<li>无缓冲通道在读写时会引起阻塞，可以用来控制程序生命周期</li>
<li>带default分支的select语句会尝试读写通道，而不会阻塞</li>
<li>可以利用无缓冲通道创建一个工作池，统一管理goroutine并发任务</li>
<li>可以利用有缓冲通道创建一个资源池，统一管理并发时的资源访问</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ixx.life/97ThingsEveryProgrammerShouldKnow/30/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Philon">
      <meta itemprop="description" content="一个程序员的成长足迹">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="自增人生">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/97ThingsEveryProgrammerShouldKnow/30/" class="post-title-link" itemprop="url">不要重复自我</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-02 10:13:14" itemprop="dateCreated datePublished" datetime="2019-03-02T10:13:14+08:00">2019-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/" itemprop="url" rel="index"><span itemprop="name">程序员应该知道的97件事</span></a>
                </span>
            </span>

          
            <span id="/97ThingsEveryProgrammerShouldKnow/30/" class="post-meta-item leancloud_visitors" data-flag-title="不要重复自我" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/97ThingsEveryProgrammerShouldKnow/30/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/97ThingsEveryProgrammerShouldKnow/30/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_30/">Don’t Repeat Yourself</a></p>
<p>编程的所有原则中，不要重复自我(DRY)或许是最基本的原则之一。该原则被Andy Hunt和Dave Thomas的《程序员修炼之道》一书中提出，便成了很多为知名软件开发的最佳实践和设计模式的基础。开发人员学习辨认副本，并理解如何通过适当的实践和抽象来消除这些重复，相比于一直被传染多余的重复代码的应用程序，可以产出更简洁的代码。</p>
<h2 id="复制是种浪费"><a href="#复制是种浪费" class="headerlink" title="复制是种浪费"></a>复制是种浪费</h2><p>应用程序的代码中的每行代码都将会维护，也将会成为潜在的bug。重复会使代码库不必要的臃肿，结果让bug有机可乘，并增加系统的耦合度。重复的臃肿加入系统也会让开发者难以彻底理解系统全貌而，还有一点可以确定，另外为了确保它们能正常工作，修改了某处的逻辑也需要修改另一处的复制。DRY需要“系统内每处的知识都必须具有单一、明确、权威的表示”。</p>
<h2 id="过程中的重复要自动化"><a href="#过程中的重复要自动化" class="headerlink" title="过程中的重复要自动化"></a>过程中的重复要自动化</h2><p>很多软件开发中的流程都是简单而重复的自动化。DRY原则适用于这些应用程序源码中的上下文。手动测试太慢了，容易出错，也很难重复操作，所以如果可能的话，自动化测试套件应该被用起来。如果手动进行软件集成可能会耗时且容易出错，因此构建过程应尽可能频繁地运行，理想情况下每次签入(代码库)时都跑一遍。只要存在能被自动化的痛苦的人工流程，都应该被自动化和标准化。其目标是确保仅有唯一的方式来完成任务，并且要尽可能做到无痛。</p>
<h2 id="逻辑中的重复要抽象"><a href="#逻辑中的重复要抽象" class="headerlink" title="逻辑中的重复要抽象"></a>逻辑中的重复要抽象</h2><p>逻辑中的重复会有很多形式。复制粘贴if-then或switch-case逻辑是最容易检查并纠正的。很多设计模式都有明确的目标，要降低或消除应用程序中的重复。如果一个对象在使用前需要同时具备几个事情的发生，就可以用抽象工厂或者工厂方法来完成。如果一个对象的行为会有很多可能的变化，这些行为就可以通过策略模式来注入，要好于大量的if-then结构。事实上，设计模式本身的制定是为了降低常见问题带来的重复，并讨论这些解决方案。此外，DRY可以适用于数据结构，如数据库模式，从而更规范。</p>
<h2 id="一个原则问题"><a href="#一个原则问题" class="headerlink" title="一个原则问题"></a>一个原则问题</h2><p>其它的软件原则也和DRY相关。<strong>有且仅有一次原则</strong>，仅适用于代码功能行为，可以被认为是DRY的一个子集。<strong>开闭原则</strong>，“软件中的实体应对扩展开放，对修改封闭”的情况，仅在遵循DRY时才能在实践中起作用。同样众所周知的<strong>单一职责原则</strong>，需要一个类“只有一个改变原因”依赖于DRY。</p>
<p>当遵循结构、逻辑、流程、以及函数时，DRY原则能为开发人员提供基本指导，并帮助创建更简单，更易于维护，更高质量的应用。尽管有一些情况下，必须用重复来满足性能或其它需求(例如数据库中的非规范化数据)，它应该被直接用于解决实际而非想象的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ixx.life/97ThingsEveryProgrammerShouldKnow/29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Philon">
      <meta itemprop="description" content="一个程序员的成长足迹">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="自增人生">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/97ThingsEveryProgrammerShouldKnow/29/" class="post-title-link" itemprop="url">不要依赖“魔法出现”</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-26 07:56:41" itemprop="dateCreated datePublished" datetime="2019-02-26T07:56:41+08:00">2019-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/" itemprop="url" rel="index"><span itemprop="name">程序员应该知道的97件事</span></a>
                </span>
            </span>

          
            <span id="/97ThingsEveryProgrammerShouldKnow/29/" class="post-meta-item leancloud_visitors" data-flag-title="不要依赖“魔法出现”" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/97ThingsEveryProgrammerShouldKnow/29/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/97ThingsEveryProgrammerShouldKnow/29/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_29/">Don’t Rely on “Magic Happens Here”</a></p>
<p>如果你看过足够多的任何活动、流程、或纪律，它们都看起来很简单。一个没有开发经验的经理会认为程序员做的事情很简单，同样的，一个没有管理经验的程序员也会这么看待经理所做的事情。</p>
<p>编程是一些人在一些时候做的事情。其中困难的部分——思考——是最不容易被外行看到和赞赏的。几十年来，已经有许多尝试想要移除这些熟练思维的需求。最近的也是最难忘的一个是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%91%9B%E9%BA%97%E7%B5%B2%C2%B7%E9%9C%8D%E6%99%AE">格蕾丝·赫柏(Grace Hopper)</a>致力于使编程语言不那么神秘——一些人语言这将消除对专业程序员的需求。结果(COBOL语言)在随后的几十年中为大量的专业程序员的收入作出了贡献。</p>
<p>消除编程以简化软件开发是个长久的愿景，对于熟知其(内部的)复杂程序的程序员而言，显然很天真。但是导致这些错误的心理过程是人性的一部分，程序员也会想他人一样容易出现。</p>
<p>在任何项目中，有很多潜在的事情是个别程序员没有积极参与的：从用户中引出需求，获得预算审批，设置构建服务器，部署应用到质量保证和生产环境，从旧的流程或程序中迁移业务，等等。</p>
<p>当你无法积极参与到某件事中时，就会无意识地趋于假设它们都很简单或着会有“魔法”出现。尽管魔法持续出现让一切安稳。但是——它们通常是“何时”而不是“如果”——魔法的停止了，该项目就会陷入困境。</p>
<p>我知道项目于会消耗掉数周开发者的时间，因为没有一个人了解该怎样加载它们依赖的“正确”版本的dll。当事情开始断断续续地出错时，在有人注意到正在加载“一个错误”版本的dll之前，团队成员还在任何地方查找。</p>
<p>其它部门运转平稳——项目准时交付，没有推迟夜间调试会议，没有紧急修复。如此平稳，事实上，高级经理都觉得这事能“自己运转”，它们都不需要管理者了。然而6个月内，该部门的项目看起来就像组织的多余部分一样——太迟了，疯狂连续的打补丁。</p>
<p>你不需要理解所有的让你项目工作的魔法，但理解它的一部分也没坏处——或者感激那些懂得你未知领域的人。</p>
<p>最重要的是，确保当魔法停止的时候，它可能再次启动。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ixx.life/books/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Philon">
      <meta itemprop="description" content="一个程序员的成长足迹">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="自增人生">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/books/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/" class="post-title-link" itemprop="url">《清醒思考的艺术》读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-24 18:00:25" itemprop="dateCreated datePublished" datetime="2019-02-24T18:00:25+08:00">2019-02-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6/" itemprop="url" rel="index"><span itemprop="name">读书</span></a>
                </span>
            </span>

          
            <span id="/books/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/" class="post-meta-item leancloud_visitors" data-flag-title="《清醒思考的艺术》读书笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/books/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/books/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先要肯定，这本书的阅读体验非常好，本书总结了52种生活“常见”的思维误区，每一种都是一千字左右的总结，其内容浅显易懂但又略带颠覆，加上一些配图，读起来干净利落。</p>
<p>不过阅读归阅读，这种观点“零散”的内容不利于写书评，我也不打算给每种思维错误都写个总结——毕竟就一千多字，还不如读原文。所以我只是简单地穿插其中的一些我认为比较重要的观点，整理成文。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/books/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ixx.life/GoInAction/chapter6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Philon">
      <meta itemprop="description" content="一个程序员的成长足迹">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="自增人生">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GoInAction/chapter6/" class="post-title-link" itemprop="url">六：并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-24 15:30:02" itemprop="dateCreated datePublished" datetime="2019-02-24T15:30:02+08:00">2019-02-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8AGO%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">《GO语言实战》学习笔记</span></a>
                </span>
            </span>

          
            <span id="/GoInAction/chapter6/" class="post-meta-item leancloud_visitors" data-flag-title="六：并发" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/GoInAction/chapter6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/GoInAction/chapter6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>但凡复杂一点的业务，并发基本跑不了，其实说白了无非是多线程/多进程架构，可一旦涉及并发模式，少不了调度、同步、互斥、资源访问等一堆堆问题，解决这些问题又需要一堆堆代码，这些代码不仅维护难度高，而且可以说和业务本身没有半毛钱关系(纯粹的技术问题有木有)。</p>
<p>But！GO语言对并发的运用相比其它语言还是相当愉快的。根据本章内容可以学到，GO语言的“多线程”机制goroutine，以及多线程之间的通信方式channel。</p>
<h2 id="GO运行时-runtime"><a href="#GO运行时-runtime" class="headerlink" title="GO运行时(runtime)"></a>GO运行时(runtime)</h2><p>在说GO的并发之前需要先搞清楚一件事，否则后面会一头雾水。</p>
<p>由于前几章并没有特别说明，加上<code>go build</code>命令可以直接生成一个独立的可执行文件(而且没有任何依赖)，会让人误以为go程序是类似c/c++一样的机器码。其实不然，<strong>GO的可执行文件内部嵌入了runtime，本质上和Java/.Net一样跑在虚拟机之上</strong>。</p>
<p>GO的运行时负责内存管理、垃圾回收、栈处理等等，而其中一个很重要的功能便是goroutine和channel的管理。</p>
<p>通常情况下，GO运行时默认给整个应用程序分配一个逻辑处理器，逻辑处理器会绑定到物理处理器上。一个GO程序默认最多创建10000个线程，但可以通过runtime包的<code>SetMaxThreads</code>方法来修改，程序里的线程超出最大线程数会导致程序崩溃。</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>所以通过上述要搞懂，goroutine不是系统分配的线程，更不归操作系统调度，一切都是靠运行时分配和调度。但不论如何，为了便于前期的学习和理解并发，这里默认goroutine就是线程。</p>
<p>先来创建10个线程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="number">10</span>) <span class="comment">// WaitGroup计数加10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="comment">// 创建goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Goroutine-%d\n&quot;</span>, id)</span><br><span class="line">      wg.Done() <span class="comment">// WaitGroup计数减1</span></span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wg.Wait() <span class="comment">// 等待，直到WaitGroup计数为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Goroutine-2</span><br><span class="line">Goroutine-9</span><br><span class="line">Goroutine-1</span><br><span class="line">Goroutine-3</span><br><span class="line">Goroutine-5</span><br><span class="line">Goroutine-8</span><br><span class="line">Goroutine-4</span><br><span class="line">Goroutine-7</span><br><span class="line">Goroutine-6</span><br><span class="line">Goroutine-0</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，for循环只是顺序创建了10个goroutine，但输出是并行的，没有顺序。</p>
<p>再强调一遍，<strong>goroutine不是线程</strong></p>
<p>尽管从效果上看，goroutine就是线程，但事实是上边的程序只有一个线程，交由go运行时维护，线程内部会自动负责多个goroutine的调度管理。</p>
<h2 id="并发竞争"><a href="#并发竞争" class="headerlink" title="并发竞争"></a>并发竞争</h2><p>有并发的地方，就有资源竞争。只需要把上边的代码稍作改动：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span> <span class="comment">// 声明一个全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done() <span class="comment">// 👈匿名函数退出时调用</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> num = count <span class="comment">// 读全局变量</span></span><br><span class="line">      fmt.Printf(<span class="string">&quot;num = %d\n&quot;</span>, num)</span><br><span class="line">      count = num + <span class="number">1</span> <span class="comment">// 写全局变量</span></span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">  <span class="comment">// 所有goroutine结束后，count值并不为5</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;count = %d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------程序输出结果(每次都是随机的)--------</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">count = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上述这段代码可以非常明显的看到，5个goroutine都对全局变量<code>count</code>做了加1的运算，结果count最终值却是1而非5。这也说明，在没有措施的情况下并发去访问全局变量会出现诡异的结果。</p>
<p>道理很简单，一个goroutine再访问某个资源时另一个goroutine可能正在写，导致访问结果不符合预期，或者你前脚刚写，后脚就被他人覆盖了。要解决这个问题，GO语言提供了两种传统思路：</p>
<ol>
<li><p>原子操作函数，确保每次访问都是完整的读写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// atomic包里还有很多如读取、写入等安全访问函数</span></span><br><span class="line"><span class="comment">// 这里仅使用加法计算</span></span><br><span class="line">atomic.AddInt64(&amp;count, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>互斥锁，我在访问的时候你不准访问</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex sync.Mutex <span class="comment">// 用来定义代码临界区</span></span><br><span class="line">mutex.Lock() <span class="comment">// 加锁，其它goroutine会被阻塞</span></span><br><span class="line">...</span><br><span class="line">mutex.Unlock() <span class="comment">// 解锁，其它goroutine继续运行</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>原子函数和互斥锁都可以很好地解决资源共享的问题，但它们都不够优秀，因为你不得不考虑程序的运行逻辑、优先级之类的问题。仔细想想，其实我们访问共享资源无非是为了生产/消费数据，只是为了确保数据能被安全访问才引入这样那样的竞争机制。那有没有一种办法能让开发者专注处理数据，不要去操心那些毫不相关的业务逻辑。答案就是GO的通道机制。</p>
<p>简单来说，一个goroutine需要读数据的时候，就从通道里去拿，处理完了就放回通道，至于那些资源互斥等问题，运行时已经处理得很完美了。</p>
<h3 id="通道的基本使用"><a href="#通道的基本使用" class="headerlink" title="通道的基本使用"></a>通道的基本使用</h3><ul>
<li>用<code>make</code>和<code>close</code>来创建和关闭通道</li>
<li>通道一般运行在goroutine函数内</li>
<li>使用<code>&lt;-</code>完成通道数据的读写</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收端goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(data <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  num := &lt;-data <span class="comment">// 将通道数据读取到变量</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;received number: %d\n&quot;</span>, num)</span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送端goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(data <span class="keyword">chan</span> <span class="keyword">int</span>, num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;sent number: %d\n&quot;</span>, num)</span><br><span class="line">  data &lt;- num <span class="comment">// 将数据写入通道</span></span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UseChannel 通道的基本使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UseChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">  channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 创建一个通道</span></span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">go</span> receive(channel)</span><br><span class="line">  <span class="keyword">go</span> send(channel, <span class="number">20</span>)</span><br><span class="line">  wg.Wait()</span><br><span class="line">  <span class="built_in">close</span>(channel) <span class="comment">// 关闭通道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，通过<code>channel := make(chan int)</code>创建了一个int类型的通道，且通过该通道实现在<code>recevie</code>和<code>send</code>两个goroutine之间的数据通信，注意<code>channel &lt;- value</code>表示写通道，<code>value &lt;- channel</code>表示读通道。</p>
<p>另外，GO提供两种通道机制，无缓冲通道和有缓冲通道。</p>
<h3 id="无缓冲通道"><a href="#无缓冲通道" class="headerlink" title="无缓冲通道"></a>无缓冲通道</h3><p>顾名思义，无缓冲就是在通道内不没有缓冲空间，对于两个goroutine而言，需要双方同时做好准备才能进行数据传递，否则先做好准备的一方就会阻塞，等待另一方做好准备。如下图所示：</p>
<p><img src="https://i.loli.net/2019/02/24/5c7239ab48e43.png" alt="无缓冲通道示意图"></p>
<p>其实最开始关于<code>send</code>和<code>recevie</code>的例子就是典型的无缓冲通道，所以具体的用法就不再赘述了。</p>
<p>留意一下两个函数中<code>fmt.Printf</code>的顺序，发送者是在发送数据之前打印，而接受者是在接收数据之后打印。不过，两个函数是goroutine，理论上来说独自运行，打印没有先后次序，但上边的例子不论运行多少次都是先打印<code>”sent number: xx&quot;</code>再打印<code>”received number: xx&quot;</code>。由此可见，因为没有缓冲，<code>num := &lt;-data</code>的时候，如果data通道的对面没有在写入，这里就会被阻塞。</p>
<h3 id="有缓冲通道"><a href="#有缓冲通道" class="headerlink" title="有缓冲通道"></a>有缓冲通道</h3><p>同理，有缓冲就是在通道内有缓冲空间，对于两个goroutine而言，无所谓对方有没有做好准备，它们只需要关系通道内的缓存有没有数据，如下图所示：</p>
<p><img src="https://i.loli.net/2019/02/24/5c7239d3d806f.png" alt="有缓冲通道示意图"></p>
<p>下面这段代码也展示了如果运用有缓冲通道，其实非常简单，就是在创建通道的时候指定一下通道的缓存长度<code>make(chan &lt;type&gt;, &lt;length&gt;)</code>即可，其它地方几乎不用变。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BufferChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个长度为10的有缓冲通道</span></span><br><span class="line">  bufferedChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">  wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动5个goroutine接收数字</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> receive(bufferedChannel)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 启动5个goroutine发送随机5个数字</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> send(bufferedChannel, rand.Intn(<span class="number">100</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">  <span class="built_in">close</span>(bufferedChannel)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------程序输出结果------------</span></span><br><span class="line">sent number: <span class="number">81</span></span><br><span class="line">received number: <span class="number">81</span></span><br><span class="line">sent number: <span class="number">81</span></span><br><span class="line">sent number: <span class="number">87</span></span><br><span class="line">sent number: <span class="number">47</span></span><br><span class="line">received number: <span class="number">81</span></span><br><span class="line">received number: <span class="number">87</span></span><br><span class="line">received number: <span class="number">47</span></span><br><span class="line">sent number: <span class="number">59</span></span><br><span class="line">received number: <span class="number">59</span></span><br></pre></td></tr></table></figure>

<p>从这样的程序输出结果可以明显看到，<code>receive</code>和<code>send</code>的执行根本互不影响，不存在阻塞的情况，否则就不会出现连续发送和连续接收的打印了。</p>
<p>但是需要注意一点，发送数字和接收数字的顺序确实一样的，也就是说有缓冲通道内部，数据是按照先进先出的方式在管理。</p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><ul>
<li>GO语言并发是指goroutine，由GO的运行时负责管理</li>
<li>使用<code>go</code>关键字来创建goroutine</li>
<li><code>sync/atomic</code>和<code>sync.Mutex</code>可以解决并发时的资源竞争问题</li>
<li>相比于原子函数和互斥锁，GO语言的通道机制可以更好地处理共享数据</li>
<li>使用<code>make(chan &lt;type&gt;)</code>创建无缓冲通道</li>
<li>使用<code>make(chan &lt;type&gt;, &lt;length&gt;)</code>创建有缓冲通道</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ixx.life/97ThingsEveryProgrammerShouldKnow/28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Philon">
      <meta itemprop="description" content="一个程序员的成长足迹">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="自增人生">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/97ThingsEveryProgrammerShouldKnow/28/" class="post-title-link" itemprop="url">不要僵直钉死你的程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-21 09:26:45" itemprop="dateCreated datePublished" datetime="2019-02-21T09:26:45+08:00">2019-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/" itemprop="url" rel="index"><span itemprop="name">程序员应该知道的97件事</span></a>
                </span>
            </span>

          
            <span id="/97ThingsEveryProgrammerShouldKnow/28/" class="post-meta-item leancloud_visitors" data-flag-title="不要僵直钉死你的程序" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/97ThingsEveryProgrammerShouldKnow/28/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/97ThingsEveryProgrammerShouldKnow/28/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_28/">Don’t Nail Your Program into the Upright Position</a></p>
<p>我有次写了一个C++恶搞比赛，我讽刺地建议了以下的异常处理策略：</p>
<blockquote>
<p>凭借遍布我们整个代码库的<code>try...catch</code>的结构，我们有时能够阻止程序的终止。我们把这种状态认为是“直立钉尸”。</p>
</blockquote>
<p>尽管我的草率，实际上我还是总结了从这位祥林嫂(Dame Bitter Experience——或者叫艰苦岁月女？🥵)膝上学到的一课。</p>
<p>这是我们自制的C++库，是应用程序的一个基类。多年以后它被千“猿”所指：没有谁的手是干净的。它包含的代码把任何事情的异常都做了避开处理。通过Yossarian的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Catch-22">第22条军规(Catch-22)</a>作为指导，我们决定，或者说倾向于这个类的一个实例要么总是活着，要么赶紧死掉。(<em>决定</em>暗示更多想法，而不仅仅是进入这只怪物的结构)</p>
<p>为此，我们把多个异常交织在一起处理。我们把Windows的结构化异常与原生的类型混合在一起处理(记住C++中的__try..__except？我都没有)。当有意外抛出时，我们尝试再次调用，更难压入参数。回头看，我喜欢把一个<code>try...catch</code>处理写到另一个catch语句中，鬼使神差的让我可能从原本良好做法的高速公路走到了一条支路，进入一条芳香四溢但很不健康的疯狂车道。然而，这很可能是事后诸葛亮。</p>
<p>不用说，程序无论何时出错了，基本都是因为这个类，它们的消失就像是在码头的黑手党遇害者，只留下没用的气泡，鬼才知道发生了什么，尽管据说转储例程会记录这场灾难。最终——很长的最终——我们盘点了所做的事情，并因此感到羞愧。我们用一个小巧且健壮的报告机制替换了这个肮脏的家伙。但这是十分让人崩溃的。</p>
<p>我不会打扰你——去确认还有谁会向我们一样蠢——但我最近在线上和一个家伙讨论问题，他的学术职称表明他应该很牛逼。我们一起讨论了Java代码关于远程传输。如果代码失败了，他认为，应该在原地捕获并阻止异常。(“接下来做什么？” 我问。“拿去做夜宵么？”)</p>
<p>他引用了UI设计师的法则：<strong>永远不要让用户看到异常报告</strong>(大写)，看似好像解决了问题，但这些大写的和任何内容又是什么。我想知道他是否会对这段代码负责：就是大量ATM机中的一台蓝屏了的照片，并造成了永久性创伤。无论如何，如果你见到了他，点头、微笑、不用声张，就像你走向这道门一样。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ixx.life/books/%E8%87%AA%E7%A7%81%E7%9A%84%E5%9F%BA%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Philon">
      <meta itemprop="description" content="一个程序员的成长足迹">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="自增人生">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/books/%E8%87%AA%E7%A7%81%E7%9A%84%E5%9F%BA%E5%9B%A0/" class="post-title-link" itemprop="url">《自私的基因》读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-19 16:54:31" itemprop="dateCreated datePublished" datetime="2019-02-19T16:54:31+08:00">2019-02-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6/" itemprop="url" rel="index"><span itemprop="name">读书</span></a>
                </span>
            </span>

          
            <span id="/books/%E8%87%AA%E7%A7%81%E7%9A%84%E5%9F%BA%E5%9B%A0/" class="post-meta-item leancloud_visitors" data-flag-title="《自私的基因》读书笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/books/%E8%87%AA%E7%A7%81%E7%9A%84%E5%9F%BA%E5%9B%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/books/%E8%87%AA%E7%A7%81%E7%9A%84%E5%9F%BA%E5%9B%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我在很多书里看到对道金斯这本《自私的基因》的引用，感觉应该是一本奇书，最近终于有幸拜读一番，果然很精彩。正如道金斯自己所说，希望作者把它当作一本科幻小说来阅读，其内容涵盖哺乳动物、鸟类、昆虫等诸多“有趣”的行为或现象，以及大量的形象比喻，关于生命的生存与繁衍背后的“道理”讲得非常浅显易懂。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/books/%E8%87%AA%E7%A7%81%E7%9A%84%E5%9F%BA%E5%9B%A0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ixx.life/GoInAction/chapter5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Philon">
      <meta itemprop="description" content="一个程序员的成长足迹">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="自增人生">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GoInAction/chapter5/" class="post-title-link" itemprop="url">五：类型系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-18 21:51:17" itemprop="dateCreated datePublished" datetime="2019-02-18T21:51:17+08:00">2019-02-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8AGO%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">《GO语言实战》学习笔记</span></a>
                </span>
            </span>

          
            <span id="/GoInAction/chapter5/" class="post-meta-item leancloud_visitors" data-flag-title="五：类型系统" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/GoInAction/chapter5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/GoInAction/chapter5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>类型——比“类”多了一个字而已，如果懂面向对象的话，类型的很多内容其实和面向对象<strong>语言</strong>如出一辙，但不同于面向对象<strong>思想</strong>。换而言之，Java/C#等常见的类的属性、方法、接口、继承等等形式，在GO的类型系统里都能找到身影，但其实现过程和思路却截然不同。</p>
<p>为了巩固本章的知识点，我仿照传统的MVC架构来实现一个“账户管理”的业务，作为GO与Java在实现面向对象方面的思想类比。在源码的<code>account</code>包中包含：</p>
<ul>
<li><code>user</code>——用户类型，基础模型</li>
<li><code>admin</code>——管理员类型，“继承”于user</li>
<li><code>show</code>——视图，用户信息打印，用接口实现user和admin多态</li>
<li><code>manage</code>——服务，负责用户的增删改查</li>
</ul>
<h2 id="类型的定义"><a href="#类型的定义" class="headerlink" title="类型的定义"></a>类型的定义</h2><p>在GO语言中定义一个类是非常简单的：<code>type user struct &#123;&#125;</code>，当然，它不叫类，而是结构类型，很像C语言中的结构体。</p>
<p>在<code>user.go</code>里声明了两个类型：<code>Password</code>和<code>User</code>，高手一看便知Password其实就是内置的string类型，感觉两者是可以互换的。然而一旦做了这样的声明之后，GO的编译器就会吧Password和string严格当作两种独立的类型来处理。换句话说，不能把string定义的变量直接赋值给Password类型的对象，只能在初始化时接收纯字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Password <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID       <span class="keyword">int</span>      <span class="comment">// 包外可见</span></span><br><span class="line">  Name     <span class="keyword">string</span>   <span class="comment">// 包外可见</span></span><br><span class="line">  password Password <span class="comment">// 包内可见</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，需要注意GO语言的符号可见性。以下情况适用于函数、变量、方法、属性等：</p>
<ul>
<li>首字母大写的符号——包外可见</li>
<li>首字母小写的符号——仅包内可见</li>
</ul>
<p>结构类型的使用也非常简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并初始化一个结构</span></span><br><span class="line">user := User&#123;</span><br><span class="line">  ID:   <span class="number">112233</span>,</span><br><span class="line">  Name: <span class="string">&quot;philon&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">user := User&#123;<span class="number">112233</span>, <span class="string">&quot;philon&quot;</span>, <span class="string">&quot;123456&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改属性</span></span><br><span class="line">user.password = <span class="string">&quot;56789&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="类型的方法"><a href="#类型的方法" class="headerlink" title="类型的方法"></a>类型的方法</h2><p>根据面向对象的套路，定义了类型的属性，自然少不了要定义方法，但GO语言不允许直接把一个类型的方法定义在其内部，而是可以将其定义在任何其他地方。如果习惯了Java这种方式，可能会觉得十分别扭，但这正是GO类型灵活的地方。如果你觉得某个“业务对象”需要某个特殊的方法来处理，那就直接加上好了，不影响它的继承、耦合等问题。</p>
<p>给类型添加一个方法的基本语法为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// u表示接收者，可以理解为面向对象中的一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">method_name</span><span class="params">()</span></span> &#123;</span><br><span class="line">  u.name = <span class="string">&quot;philon&quot;</span></span><br><span class="line">  u.email = <span class="string">&quot;xxx@xxx.com&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过添加方法时需要注意“接受者”的区别，主要有两种：</p>
<ul>
<li><code>值接收者</code>的方法在其内部修改对象的值，不改变外部调用者</li>
<li><code>指针接收者</code>的方法在其内部修改对象的值，改变外部调用者</li>
</ul>
<p>还是以代码为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值接受者方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">Auth</span><span class="params">(p Password)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  u.password = <span class="string">&quot;123456&quot;</span> <span class="comment">// 👈此行并不影响外部调用对象</span></span><br><span class="line">  <span class="keyword">return</span> u.password == p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接受者方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">SetPassword</span><span class="params">(p Password)</span></span> &#123;</span><br><span class="line">  u.password = p <span class="comment">// 👈同时修改了外部调用对象的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果理解函数调用的内存管理，那这两种形式非常容易理解。调用函数的时候，传入的参数将拷贝一个副本并压栈，函数通过访问栈区来获取参数值。换句话说：<strong>所有传入函数的参数其实都只是副本</strong>，在函数内部修改副本的值，不会影响原始参数值。</p>
<p>✍️<strong>但务必注意</strong>✍️</p>
<p>Go语言里的引用类型：切片、映射、通道、接口和函数是比较特殊的，前几章已经说明了它们作为参数在函数间传递时，本身就是以引用形式传递，所以<strong>引用类型的方法，值接受者其实是个引用(指针)副本</strong>。千万小心。</p>
<h2 id="嵌入类型-继承"><a href="#嵌入类型-继承" class="headerlink" title="嵌入类型(继承)"></a>嵌入类型(继承)</h2><p><code>User</code>类型的属性和方法都实现了，在面向对象里面自然少不了继承，例如管理员账户<code>Administrator</code>类型一般而言都会继承User。GO语言对继承的形式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Administrator 管理员用户</span></span><br><span class="line"><span class="keyword">type</span> Administrator <span class="keyword">struct</span> &#123;</span><br><span class="line">  User  <span class="comment">// 通过嵌套，继承“父类”</span></span><br><span class="line">  Level <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">a := Administrator&#123;</span><br><span class="line">  User: &#123; <span class="number">1</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;password&quot;</span> &#125;,</span><br><span class="line">  Level: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> a Administrator</span><br><span class="line">a.ID = <span class="number">1</span></span><br><span class="line">a.Name = <span class="string">&quot;root&quot;</span></span><br><span class="line">a.Level = <span class="number">123</span></span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口在第二章中其实总结了很多了，GO语言的接口属于<code>鸭子类型</code>——也就是一个类型只要实现了接口的方法，不管它们是否存在继承关系，都能够以多态的形式调用。</p>
<p>这里以<code>Shower</code>接口为例，该接口要求实现一个<code>show</code>方法，用于打印一个类型的内部信息。和面向对象的思路一样，各个类型实现自己的show方法，而Shower只负责调用。</p>
<p>首先是接口的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shower 显示接口的定义</span></span><br><span class="line"><span class="comment">// 根据GO的规则，如果一个接口只有一个方法，那就叫方法名+er</span></span><br><span class="line"><span class="keyword">type</span> Shower <span class="keyword">interface</span> &#123;</span><br><span class="line">  show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShowInfo 任何实现了show的类型都可以传入该函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowInfo</span><span class="params">(s Shower)</span></span> &#123;</span><br><span class="line">  s.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是<code>User</code>和<code>Administrator</code>的不同show实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User类型实现show接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;User %s&lt;%d&gt;\n&quot;</span>, u.Name, u.ID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Administrator实现show接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Administrator)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Administrator %s(%d): Level-%d\n&quot;</span>, a.Name, a.ID, a.Level)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们定义了两个类型的变量，并通过ShowInfo调用</span></span><br><span class="line">ShowInfo(user)  <span class="comment">// User philon&lt;112233&gt;</span></span><br><span class="line">ShowInfo(admin) <span class="comment">// Administrator root(0): Level-123</span></span><br></pre></td></tr></table></figure>

<p>从上边的例子可以看到，user和admin虽然是不同的类型，但是由于都实现了show这个接口方法，因此都可以传入<code>ShowInfo</code>函数，并且也实际调用到了它们各自的实现。</p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><ul>
<li>type xxx struct 定义一个结构类型</li>
<li>type xxx interface 定义一个接口</li>
<li>不管是类型、函数还是成员变量，首字母大写表示包外可见，否则包内可见</li>
<li>type xxx struct { OtherType }即可继承其它结构类型</li>
<li>func (t Type) foo() 定义一个类型的方法</li>
<li>值接受者定义的类型方法，调用者传入副本，方法内修改对象不影响外部</li>
<li>指针接受者定义的类型方法，调用者传入地址，方法内修改对象影响外部</li>
<li>接口是实现多态的类型，只要实现了接口方法，任何类型都可以调用</li>
<li>标识符首字母大写是包外公开，小写仅包内公开</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Philon"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Philon</p>
  <div class="site-description" itemprop="description">一个程序员的成长足迹</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">177</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/philon" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;philon" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ixx.life</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Y5scg9Ix4iae04UOae0uJSJA-gzGzoHsz',
      appKey     : 'U9hHApgNVDExYRJqXvUs5ykr',
      placeholder: "说点什么吧...",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
