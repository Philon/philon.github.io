<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo48x48.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo48x48.png">
  <link rel="mask-icon" href="/images/logo.png" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ixx.life","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我们可以通过goroutine和channel机制非常方便地编写并发业务，但就和面向对象与设计模式的关系一样，是一种思想具体落实到行动方针的过程，在牛逼的战略，没有基本的战术指导，也只是空谈。 因此，第七章并发模式，并没有太多语法上的新东西，而是利用goroutine和channel介绍了三种并发模式，分别适用于三种不同的业务场景。  runner——给每个并发任务设置deadline，管理并发任">
<meta property="og:type" content="article">
<meta property="og:title" content="七：并发模式">
<meta property="og:url" content="https://ixx.life/GoInAction/chapter7/index.html">
<meta property="og:site_name" content="自增人生">
<meta property="og:description" content="我们可以通过goroutine和channel机制非常方便地编写并发业务，但就和面向对象与设计模式的关系一样，是一种思想具体落实到行动方针的过程，在牛逼的战略，没有基本的战术指导，也只是空谈。 因此，第七章并发模式，并没有太多语法上的新东西，而是利用goroutine和channel介绍了三种并发模式，分别适用于三种不同的业务场景。  runner——给每个并发任务设置deadline，管理并发任">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-03-03T08:13:01.000Z">
<meta property="article:modified_time" content="2021-07-21T22:56:15.019Z">
<meta property="article:author" content="Philon">
<meta property="article:tag" content="GO语言">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ixx.life/GoInAction/chapter7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>七：并发模式 | 自增人生</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">自增人生</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">何以解忧，唯有 i++</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa  fa-book fa-fw"></i>读书写作</a>

  </li>
        <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-pen fa-fw"></i>学习笔记</a>

  </li>
        <li class="menu-item menu-item-leetcode">

    <a href="/leetcode/" rel="section"><i class="fa fa-fire fa-fw"></i>LeetCode</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ixx.life/GoInAction/chapter7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Philon">
      <meta itemprop="description" content="一个程序员的成长足迹">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="自增人生">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          七：并发模式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-03 16:13:01" itemprop="dateCreated datePublished" datetime="2019-03-03T16:13:01+08:00">2019-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8AGO%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">《GO语言实战》学习笔记</span></a>
                </span>
            </span>

          
            <span id="/GoInAction/chapter7/" class="post-meta-item leancloud_visitors" data-flag-title="七：并发模式" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/GoInAction/chapter7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/GoInAction/chapter7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>我们可以通过goroutine和channel机制非常方便地编写并发业务，但就和面向对象与设计模式的关系一样，是一种思想具体落实到行动方针的过程，在牛逼的战略，没有基本的战术指导，也只是空谈。</p>
<p>因此，第七章并发模式，并没有太多语法上的新东西，而是利用goroutine和channel介绍了三种并发模式，分别适用于三种不同的业务场景。</p>
<ol>
<li>runner——给每个并发任务设置deadline，管理并发任务的生命周期</li>
<li>pool——利用有缓冲通道创建资源池，统一管理并发时的资源访问</li>
<li>work——利用无缓冲通道创建goroutine池，统一管理并发</li>
</ol>
<h2 id="runner"><a href="#runner" class="headerlink" title="runner"></a>runner</h2><p>先假设一个场景需求，比如http服务的并发，我们要为每个来自客户端的请求创建一个临时的并发响应任务，但这个最好在某个规定的时间内完成响应，否则就强制它退出，这样可以很好地避免某些情况下，一些并发任务卡死的情况，同时可以很好地管理每个并发的生命周期。  </p>
<p>runner就是为这样的场景应用而生的，runner可以理解为是一个运行管理器，所有的并发任务都要叫给它负责管理，它负责并发任务的启动、超时监控、强制中断等。</p>
<p>(由于我个人在阅读原著的时候是先讲runner的内部实现，再看实际应用，总感觉云里雾里的，觉得还是先通篇看一下如何运用runner，再来看其内部的实现，可能效果会好一点)</p>
<p>先来看runner的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testRunner</span><span class="params">()</span></span> &#123;</span><br><span class="line">  log.Println(<span class="string">&quot;Runner test starting work...&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个runner，并强制每个并发任务的超时时间为5秒</span></span><br><span class="line">  r := runner.New(<span class="number">3</span> * time.Second)</span><br><span class="line">  <span class="comment">// 循环创建10个并发任务，并将其丢给runner管理</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    r.Add(<span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="comment">// 这里只是模拟，每个并发任务都是睡眠它自身id的秒数</span></span><br><span class="line">      log.Printf(<span class="string">&quot;Processor - Task #%d.\n&quot;</span>, id)</span><br><span class="line">      time.Sleep(time.Duration(id) * time.Second)</span><br><span class="line">      log.Printf(<span class="string">&quot;Task #%d done.\n&quot;</span>, id)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次性启动runner内部的全部并发任务</span></span><br><span class="line">  <span class="keyword">if</span> err := r.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> err &#123;</span><br><span class="line">    <span class="keyword">case</span> runner.ErrTimeout:</span><br><span class="line">      <span class="comment">// 当并发任务中有任务执行超时，就立即返回</span></span><br><span class="line">      log.Println(<span class="string">&quot;Terminating due to timeout.&quot;</span>)</span><br><span class="line">      os.Exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">case</span> runner.ErrInterrupt:</span><br><span class="line">      <span class="comment">// 当程序被ctrl+c时，强制结束所有并发任务</span></span><br><span class="line">      log.Println(<span class="string">&quot;Terminating due to interrupt.&quot;</span>)</span><br><span class="line">      os.Exit(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  log.Println(<span class="string">&quot;Process end.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------程序输出---------------</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Runner test starting work...</span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">2.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">4.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">3.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">0.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Task #<span class="number">0</span> done.</span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">1.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">42</span> Task #<span class="number">1</span> done.</span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">43</span> Task #<span class="number">2</span> done.</span><br><span class="line"><span class="comment">// ----第3个及以后的任务因为要睡3秒以上，肯定会超时----</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">44</span> Terminating due to timeout.</span><br><span class="line"><span class="comment">// ----如何运行过程中按ctrl+c，会安全退出并提示----</span></span><br><span class="line">^C2019/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">49</span>:<span class="number">36</span> Terminating due to interrupt.</span><br></pre></td></tr></table></figure>

<p>可以看到，runner就是一个类型，需要用其创建对象后才能具体使用。而在外部，我们只需要定义好每个任务的函数，并简单的将它们添加到runner当中即可，剩下的全部交由runner自行管理。</p>
<p>现在再来看看runner类型是如何实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runner 在指定的超时时间内完成一组任务</span></span><br><span class="line"><span class="comment">// 并且在这个时间周期内接收系统的中断信号来结束这组任务</span></span><br><span class="line"><span class="keyword">type</span> Runner <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 从系统接收中断信号的通道</span></span><br><span class="line">  interrupt <span class="keyword">chan</span> os.Signal</span><br><span class="line">  <span class="comment">// 任务已完成的报告通道</span></span><br><span class="line">  complete <span class="keyword">chan</span> error</span><br><span class="line">  <span class="comment">// 任务超时的报告通道</span></span><br><span class="line">  timeout &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">  <span class="comment">// 任务列表</span></span><br><span class="line">  tasks []<span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrTimeout 任务执行超时时返回</span></span><br><span class="line"><span class="keyword">var</span> ErrTimeout = errors.New(<span class="string">&quot;received timeout&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrInterrupt 收到系统中断信号时返回</span></span><br><span class="line"><span class="keyword">var</span> ErrInterrupt = errors.New(<span class="string">&quot;received interrupt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 创建Runner的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(d time.Duration)</span> *<span class="title">Runner</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Runner&#123;</span><br><span class="line">    interrupt: <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>),</span><br><span class="line">    complete:  <span class="built_in">make</span>(<span class="keyword">chan</span> error),</span><br><span class="line">    timeout:   time.After(d),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add Runner的方法，将多个任务添加到Runner的任务列表中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runner)</span> <span class="title">Add</span><span class="params">(tasks ...<span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">  r.tasks = <span class="built_in">append</span>(r.tasks, tasks...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start Runner的方法，启动所有任务，并监听通道事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runner)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 开始接收系统的中断通知</span></span><br><span class="line">  signal.Notify(r.interrupt, os.Interrupt)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过gorouting并行启动所有任务列表中的任务</span></span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="built_in">len</span>(r.tasks))</span><br><span class="line">  <span class="keyword">for</span> i, t := <span class="keyword">range</span> r.tasks &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>, task <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">      task(id)</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;(i, t)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等待所有任务执行完成，并给“已完成通道”一个报告</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    r.complete &lt;- <span class="literal">nil</span></span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取无缓冲通道数据时，如果没准备好，会被阻塞</span></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> err := &lt;-r.complete: <span class="comment">// 任务正常实行完返回任务自身的“错误标示”</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  <span class="keyword">case</span> &lt;-r.timeout: <span class="comment">// 任务执行超时，返回超时错误</span></span><br><span class="line">    <span class="keyword">return</span> ErrTimeout</span><br><span class="line">  <span class="keyword">case</span> &lt;-r.interrupt: <span class="comment">// 如果收到ctrl+C则停止接收后续的信号</span></span><br><span class="line">    signal.Stop(r.interrupt)</span><br><span class="line">    <span class="keyword">return</span> ErrInterrupt</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于只是原型演示，runner的内部实现不算复杂，只需要记住一个核心思想<strong>无缓冲通道在没有数据读写的时候，会被阻塞</strong>。说千道万，runner就是利用了这个特性才得以在select语句中完成了：</p>
<ul>
<li>并行接收系统的中断信号——interrupt通道。</li>
<li>并行接收定时器的超时信号——timeout通道。</li>
</ul>
<h2 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h2><p>这里的pool是指资源池的意思，如果熟悉Java/C#中的“数据连接池”的概念，那这里的池大体就是这个意思了。</p>
<p>换而言之，在并发场景下，难免会遇到并发任务争夺临界资源的情况，还是以数据库访问为例：如果有1000个并发任务要去访问数据库，每个并发都需要完成建立连接——认证——查询——断开连接等操作，那不论是应用服务器还是数据库服务器，无疑都是巨大的负担。因此，通过创建10个数据库连接，并把这些“连接”当作资源放入“池”中，给所有的并发任务共享，每个并发在需要的时候从池中取出连接，完成查询后再放回池中，不仅能大幅降低CPU的负载，也能减少内存的开销。(但我个人觉得最爽的地方是，你的代码可以更专注地去query，而不必考虑connection本身😂)</p>
<p>同样，先来看看pool的运用过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  maxGoroutines  = <span class="number">25</span> <span class="comment">// 要使用的goroutine的数量</span></span><br><span class="line">  pooledResource = <span class="number">5</span>  <span class="comment">// 池中的资源的数量</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dbConnection 模拟要共享的资源</span></span><br><span class="line"><span class="keyword">type</span> dbConnection <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 实现io.Closer.Close接口，释放资源</span></span><br><span class="line"><span class="comment">// 让其可以被Pool管理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dbConn *dbConnection)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  log.Println(<span class="string">&quot;Close: Connection&quot;</span>, dbConn.ID)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idCounter 用来给每个连接分配唯一id</span></span><br><span class="line"><span class="keyword">var</span> idCounter <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// createConnection 创建唯一id的连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createConnection</span><span class="params">()</span> <span class="params">(io.Closer, error)</span></span> &#123;</span><br><span class="line">  id := atomic.AddInt32(&amp;idCounter, <span class="number">1</span>)</span><br><span class="line">  log.Println(<span class="string">&quot;Create: New Connection&quot;</span>, id)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;dbConnection&#123;id&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testPool Pool测试用例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testPool</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(maxGoroutines)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建管理连接池，并创建N个“连接”资源，加入池中</span></span><br><span class="line">  p, err := pool.New(createConnection, pooledResource)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建M个并发任务，模拟查询数据库</span></span><br><span class="line">  <span class="keyword">for</span> query := <span class="number">0</span>; query &lt; maxGoroutines; query++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(q <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      performQueries(q, p)</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;(query)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">  log.Println(<span class="string">&quot;Shutdown Program&quot;</span>)</span><br><span class="line">  p.Close() <span class="comment">// 关闭池</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performQueries</span><span class="params">(query <span class="keyword">int</span>, p *pool.Pool)</span></span> &#123;</span><br><span class="line">  conn, err := p.Acquire()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成查询后，将资源释放会池里</span></span><br><span class="line">  <span class="keyword">defer</span> p.Release(conn)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用随机睡眠1000微妙内的时长，来模拟查询中的耗时</span></span><br><span class="line">  time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond)</span><br><span class="line">  log.Printf(<span class="string">&quot;QID[%d] CID[%d]\n&quot;</span>, query, conn.(*dbConnection).ID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(可能是我没学习到位，我个人觉得pool模式并不是特别容易掌握，思想是很好理解的，但牵扯太多接口实现、有/无缓冲通道的特性等内容，所以代码可能要再多消化几遍。)</p>
<p>再看看pool包的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pool 资源池</span></span><br><span class="line"><span class="comment">// 管理一组资源，可以安全地在多个goroutine共享</span></span><br><span class="line"><span class="comment">// 实现 io.Closer接口</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">  m        sync.Mutex</span><br><span class="line">  resource <span class="keyword">chan</span> io.Closer</span><br><span class="line">  factory  <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.Closer, error)</span></span></span><br><span class="line">  closed   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrPoolClosed 资源池已关闭的错误标示</span></span><br><span class="line"><span class="keyword">var</span> ErrPoolClosed = errors.New(<span class="string">&quot;Pool has been closed&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 创建Pool的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(fn <span class="keyword">func</span>()</span> <span class="params">(io.Closer, error)</span>, <span class="title">size</span> <span class="title">uint</span>) <span class="params">(*Pool, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> size &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;size value too small&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;Pool&#123;</span><br><span class="line">    factory:  fn,</span><br><span class="line">    resource: <span class="built_in">make</span>(<span class="keyword">chan</span> io.Closer, size),</span><br><span class="line">  &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Acquire 从资源池中获取一个资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Acquire</span><span class="params">()</span> <span class="params">(io.Closer, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> r, ok := &lt;-p.resource:</span><br><span class="line">    <span class="comment">// 检查是否有空闲资源</span></span><br><span class="line">    log.Println(<span class="string">&quot;Acquire:&quot;</span>, <span class="string">&quot;Shared Resource&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ErrPoolClosed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果没有可用资源，就创建一个</span></span><br><span class="line">    log.Println(<span class="string">&quot;Acquire:&quot;</span>, <span class="string">&quot;New Resource&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> p.factory()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release 释放一个资源，将其放回资源池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Release</span><span class="params">(r io.Closer)</span></span> &#123;</span><br><span class="line">  p.m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果该资源已经被关闭，销毁这个资源</span></span><br><span class="line">  <span class="keyword">if</span> p.closed &#123;</span><br><span class="line">    r.Close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> p.resource &lt;- r:</span><br><span class="line">    <span class="comment">// 试图将该资源加入队列</span></span><br><span class="line">    log.Println(<span class="string">&quot;Release:&quot;</span>, <span class="string">&quot;In Queue&quot;</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果队列已满，关闭这个资源</span></span><br><span class="line">    log.Println(<span class="string">&quot;Release:&quot;</span>, <span class="string">&quot;Closing&quot;</span>)</span><br><span class="line">    r.Close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭资源池中的所有资源，并停止工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p.m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> p.closed &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p.closed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(p.resource)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭所有资源</span></span><br><span class="line">  <span class="keyword">for</span> r := <span class="keyword">range</span> p.resource &#123;</span><br><span class="line">    r.Close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pool资源池实现的核心思想是<strong>有缓冲通道读写时不会引起阻塞，select语句在通道内没有数据的情况下会自动执行default选项</strong>。</p>
<h2 id="work"><a href="#work" class="headerlink" title="work"></a>work</h2><p>work模式就是创建一个goroutine池，管理池中所有的goroutine统一执行。但它有别于runner模式，runner其实是负责监控池中的每个并发任务的生命周期的，而work则是负责池中的每个并发任务的执行顺序，即任务队列。</p>
<p>这个模式的好处在于，可以很好地控制程序运行的负载，比如突发情况下，某台服务器的http请求一瞬间到达100万，如果为了响应所有请求也在一瞬起启动100万个响应任务，那估计服务器就冒烟了。所以最好的方式就是限制并发任务数量，比如每次最多启动1万个响应，剩下的排队慢慢来。</p>
<p>因此，work就是一个并发任务的队列池，还是先看看如何运用的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = []<span class="keyword">string</span>&#123;</span><br><span class="line">  <span class="string">&quot;steve&quot;</span>,</span><br><span class="line">  <span class="string">&quot;bob&quot;</span>,</span><br><span class="line">  <span class="string">&quot;mary&quot;</span>,</span><br><span class="line">  <span class="string">&quot;therese&quot;</span>,</span><br><span class="line">  <span class="string">&quot;jason&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> namePrinter <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 实现Worker接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *namePrinter)</span> <span class="title">Task</span><span class="params">()</span></span> &#123;</span><br><span class="line">  log.Println(m.name)</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 设置工作池的“工位”为2，即每次只能有两个人工作</span></span><br><span class="line">  p := work.New(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="number">100</span> * <span class="built_in">len</span>(names)) <span class="comment">// 每人肩负100项任务，共5人</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次性把5 * 100个任务全部丢到工作池中</span></span><br><span class="line">  <span class="comment">// 相当于创建了500个goroutine</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">      np := namePrinter&#123;name: name&#125;</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p.Run(&amp;np) <span class="comment">// 将对象的任务丢到工作池中统一管理执行</span></span><br><span class="line">        wg.Done()</span><br><span class="line">      &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待所有任务在工作池中被完成</span></span><br><span class="line">  wg.Wait()</span><br><span class="line">  p.Shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码，namePrinter实现了work包内规定的<code>Task</code>接口之后，work的工作池就能够统一管理namePrinter对象了。这个namePrinter可以理解为某个业务的模拟，比如上面说的http响应任务(这里仅是简单地做个打印)。</p>
<p>而后，不论创建多少个namePrinter相关的goroutine(并发)，都只需简单地将其丢到工作池中Run(p.Run并没有立刻启动任务，工作池会根据情况自行安排)。</p>
<p>最后在看看work包的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Worker 必须满足接口，才能使用工作池</span></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">interface</span> &#123;</span><br><span class="line">  Task()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pool 工作池，相当于goroutines池管理</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">  work <span class="keyword">chan</span> Worker</span><br><span class="line">  wg   sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 创建工作池的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxGoroutines <span class="keyword">int</span>)</span> *<span class="title">Pool</span></span> &#123;</span><br><span class="line">  p := Pool&#123;</span><br><span class="line">    work: <span class="built_in">make</span>(<span class="keyword">chan</span> Worker),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p.wg.Add(maxGoroutines)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxGoroutines; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// p.work是通道，所有创建goroutine之后</span></span><br><span class="line">      <span class="comment">// for循环会被阻塞，直到p.work被关闭为止</span></span><br><span class="line">      <span class="keyword">for</span> w := <span class="keyword">range</span> p.work &#123;</span><br><span class="line">        w.Task()</span><br><span class="line">      &#125;</span><br><span class="line">      p.wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run 提交工作到工作池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Run</span><span class="params">(w Worker)</span></span> &#123;</span><br><span class="line">  p.work &lt;- w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shutdown 等待所有goroutines结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">close</span>(p.work)</span><br><span class="line">  p.wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>work的实现其实是非常简单的，<strong>核心思想是for-range循环时，无缓冲通道会阻塞</strong>，工作池是一个无缓冲通道，而每个for-range都相当于一个队列，当池中有数据是，所有的for-range都会争夺这个输入数据来处理，但如果某个队列本身已经在工作时，就没空再争夺通道内的数据。可以说是最简单有效的负载均衡。</p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><ul>
<li>无缓冲通道在读写时会引起阻塞，可以用来控制程序生命周期</li>
<li>带default分支的select语句会尝试读写通道，而不会阻塞</li>
<li>可以利用无缓冲通道创建一个工作池，统一管理goroutine并发任务</li>
<li>可以利用有缓冲通道创建一个资源池，统一管理并发时的资源访问</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Philon
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ixx.life/GoInAction/chapter7/" title="七：并发模式">https://ixx.life/GoInAction/chapter7/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/GO%E8%AF%AD%E8%A8%80/" rel="tag"># GO语言</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/97ThingsEveryProgrammerShouldKnow/30/" rel="prev" title="不要重复自我">
      <i class="fa fa-chevron-left"></i> 不要重复自我
    </a></div>
      <div class="post-nav-item">
    <a href="/books/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/" rel="next" title="三人为虎-《乌合之众》读书感悟">
      三人为虎-《乌合之众》读书感悟 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Philon"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Philon</p>
  <div class="site-description" itemprop="description">一个程序员的成长足迹</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">177</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/philon" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;philon" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ixx.life</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Y5scg9Ix4iae04UOae0uJSJA-gzGzoHsz',
      appKey     : 'U9hHApgNVDExYRJqXvUs5ykr',
      placeholder: "说点什么吧...",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
